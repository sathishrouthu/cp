##### Requirements needed to construct a unique BT
```
We should have either
inorder + pre-order
OR
inorder + post-order
to construct a unique binary tree.
```

##### Construct a BT from Preorder and Inorder
Given two integer arrays preorder and inorder. Where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree.

Construct and return the binary tree using in-order and preorder arrays.
```
In the given pre-order we will have the root at first.
we determine the in-order and pre-order of left subtree and right sub tree and then build them to attach to this root.

Finding Inorder of subtrees:
find index where root exists in the in-order : let's say this as rootIndex;
so now
elements before rootIndex in in-order array are the in-order traversal of Left  sub tree :: in-order[0....rootIndex-1]
elements after  rootIndex in in-order array are the in-order traversal of Right sub tree :: in-order[rootIndex+1....n]

Finding Pre-order of subtrees:
let's say we have K elements before rootIndex in in-order which implies we have K elements in left sub tree. Then,

K elements after the first index of pre-order array are the pre-order traversal of the left sub tree :: pre-order[1 ... K]
and the elements after Kth index in pre-order array are pre-order traversal of right sub tree :: pre-order[K+1 ... N ]
Now we have inorder and pre-order of left subtree and right subtree, solve the sub problems and attach to the current root.


instead of splitting the arrays every time, maintain the start and ind indices of in and pre order arrays to solve the problem
pre-calculate the index of every value using a hashmap since we have to find the rootIndex in inorder every time.
```
```
buildTree(pre-order, preStart, preEnd, inorder, inStart, inEnd, hashMap ){
  if(preStart>preEnd || inStart>inEnd)
    return null;
  root = preOrder[preStart];
  rootIndex = hashMap.get(root);
  int K = rootIndex - inStart;
  leftSubTree = buildTree(pre-order, preStart+1, preStart+K, inorder, inStart, rootIndex-1, hashMap)
  rightSubTree = buildTree(pre-order, preStart+K+1, preEnd, inorder, rootIndex+1, inEnd, hashMap)
  root.left = leftSubTree;
  root.right = rightSubTree;
  return root;
}
```

##### Construct a BT from Preorder and Inorder
```
Root is the last element of post-order
determine root index and inorder of left and right same as before.
k = rootIndex-inStart
postorder of left sub tree = postorder[postStart ... postStart+ k-1 ]
postorder of right subtree = postorder[postStart+k ... postEnd - 1]
```

 ##### Serialize and De-Serialize Binary Tree
 serialize(BinaryTree) : should generate a string which can be used to generate the exact same binary tree from that string.
 deserializae(String)  : should generate the binary tree from string generated in serialize(BT).

```
serialize(BinaryTree):
  do the level order traversal, if the node is null append "#" other wise node value
  separate the node values by a comma ','

deserialize(String):
  if string is empty return null as no tree exists.
  split the string by comma, and traverse the token with ind
  first value is the root, add it to the queue and do the level order until que becomes empty.
  start ind from 1 as tokens[0] is root added to queue.
  get peek node from queue,
    if tokens[ind] is '#' then add null to peek's left
    other wise
      create a node of tokens[ind] and add it to peek's left;
      add this new node to queue;
    move to next token, ind++

    if tokens[ind] is '#' then add null to peek's right
    other wise
      create a node of tokens[ind] and add it to peek's right;
      add this new node to queue;
    move to next token, ind++;
```
```java
public String serialize(TreeNode root) {
    if(root==null) return "";
    Queue<TreeNode> que = new LinkedList<>();
    que.offer(root);
    StringBuilder sb = new StringBuilder();
    while(!que.isEmpty()){
        int size = que.size();
        for(int i=0;i<size;i++){
            TreeNode top = que.poll();
            if(top==null){
                sb.append("#,");
            }else{
                sb.append(top.data+",");
                que.offer(top.left);
                que.offer(top.right);
            }
        }
    }
    return sb.toString();
}
public TreeNode deserialize(String data) {
    if(data.equals("")) return null;
    String[] tokens = data.split(",");
    int ind = 0;
    TreeNode root = new TreeNode(Integer.valueOf(tokens[ind]));
    Queue<TreeNode> que = new LinkedList<>();
    que.offer(root);
    ind++;
    while(!que.isEmpty()){
        TreeNode top = que.poll();
        TreeNode left = tokens[ind].equals("#") ? null : new TreeNode(Integer.valueOf(tokens[ind]));
        ind++;
        TreeNode right = tokens[ind].equals("#") ? null : new TreeNode(Integer.valueOf(tokens[ind]));
        ind++;
        top.left = left;
        top.right = right;
        if(left!=null) que.offer(left);
        if(right!=null) que.offer(right);
    }
    return root;
}
// 1,2,3,#,#,4,6,#,#,#,#,
```
