##### Zig Zag or Spiral Traversal
Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).
```
do the level order,
maintain flag to include elements in forward order or reverse order.

List<Integer> level = Arrays.asList(new Integer[size]);

int idx = flag ? i : size-1-i;
level.set(idx,front.data);
```

##### Boundary Traversal
Given a root of Binary Tree, perform the boundary traversal of the tree. 

The boundary traversal is the process of visiting the boundary nodes of the binary tree in the anticlockwise direction, starting from the root.
```
add Root ( if not a leave )
addLeftBoundary(root.left)
addLeaves(root)
addRightBoundary(root.right)
```

##### Vertical Order Traversal
Compute the binary tree's vertical order traversal given its root.
The left and right children of a node at location (row, col) will be at (row + 1, col - 1) and (row + 1, col + 1), respectively. The tree's root is located at (0, 0).

The vertical order traversal of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. 
There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values. Return the binary tree's vertical order traversal.
```
create a TreeMap<Integer,TreeMap<Intger,PriorityQueue>>>
it represents:

Y --> { X --> { values } }
for each vertical level(y) there are multiple rows(x)

Traverse the map,
for each Y :
  verticalLevel = []
  for each X :
    for each PQ:
      add all elements from PQ to verticalLevel
  add verticalLevel to result;
```

##### Top View
Given the root of a binary tree, return the top view of the binary tree.
```
Maintain a map of TreeMap<Integer,Integer> => Y : firstValue at yth vertical level
queue of node and it's vertical level traverse.
put only first value in map at each vertical level
-- map.putIfAbsent(y, node.data)
```
##### Bottom View
```
put the last node of the vertical level
-- map.put(y, node.data)
```

##### Left/Right side view
```
BFS Solution:
do the normal level order traveral
at each level add the first node to left View
at each level add the last node to right view.

DFS Solution:
write a recursive function to move down. f(node, level, result)
at each recursive call,
- if the result size == level then add the node value to result;
- go to left then right for left view
- go to right then left for right view

```
##### Print all root-to-leaf paths in BT
Given the root of a binary tree. Return all the root-to-leaf paths in the binary tree.
```
recursive function for dfs traversal with currNode, currPath, resultPaths
if currNode is leaf add the currPath to resultant list.

add the currNode to currPath
move left
move right
remove the currNode from currPath
```
##### Lowest Common Ancestor LCA
Given a root of binary tree, find the lowest common ancestor (LCA) of two given nodes (p, q) in the tree.

The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).
```
Bruteforce:
find path to node P from
find path to node Q from
traverse both paths from root, the last point where the both paths matches is the LCA.

Optimal:
if A is lca of B and C
then A must have
B or C in it's left sub tree.
B or C in it's right sub tree.
at each node 
check if left has B or C 
check if right has B or C
if(left doesn't have B or C) then right is the LCA
if(right doesn't have B or C) then left is the LCA
if(left has B or C and right has B or C) then the currNode is LCA.
write a recursive function f(root, P, Q)
base case: every node is ancestor of itself
```
```
f(root, P, Q)
  if root is null or root is P or root is Q :    ( every node is ancestor of itself )
      return root   
  left = f(root.left,P,Q)
  right = f(root.right,P,Q)
  if left == null :                              ( left  doesn't have P or Q )
    return right;
  if right == null :                             ( right doesn't have P or Q )
    return left;
  return root;                                   ( left has P and right has Q ) OR ( left has Q and right has P )
```

##### Count total nodes in a complete BT
Return the number of nodes in a binary tree given its root.

Every level in a complete binary tree possibly with the exception of the final one is fully filled, and every node in the final level is as far to the left as it can be. At the last level h, it can have 1 to 2h nodes inclusive.
```
Bruteforce:
do preorder or inorder or post order and count nodes;
inorder(root):
  if root == null return;
  count++;
  inorder(root.left);
  inorder(root.right);

Optimal:
Since it is a Complete binary tree,
we can get no. of nodes by just checking it's left subtree height and right sub tree height
if left height == right height:
  no. of nodes : 2^h - 1      ( the tree is complete )
else:
  1 + no. of nodes in left + no. of nodes in right

getting left/right subtree is simpler in complete BT,
as we just have to go towards left/right.
leftHeight(root):
  count=0;
  while(root!=null):
    count++;
    root = root.left;
  return count;


```





