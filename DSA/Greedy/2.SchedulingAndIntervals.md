### Shortest Job First
A software engineer is tasked with using the shortest job first (SJF) policy to calculate the average waiting time for each process. The shortest job first also known as shortest job next (SJN) scheduling policy selects the waiting process with the least execution time to run next.

Given an array of n integers representing the burst times of processes, determine the average waiting time for all processes and return the closest whole number that is less than or equal to the result.
```
bt = [4, 1, 3, 7, 2]
output is avg wt  = 4

Sort the array.
[1,2,3,4,7]
now, complete each task in the same order:
1 is completed -> 4 tasks waited 1 sec | 1 x 4
2 is completed -> 3 tasks waited 2 sec | 2 x 3
3 is completed -> 2 tasks waited 3 sec | 3 x 2
4 is completed -> 1 task  waited 4 sec | 4 x 1
7 is completed -> 0 tasks waited 7 sec | 0
total = 20
avg = 20/5 = 4
```
```java
class Solution {
    public long solve(int[] bt) {
        Arrays.sort(bt);
        int n=bt.length-1;
        long wt = 0;
        for(int i:bt){
            wt += i*n;
            n--;
        }
        return (int)(wt/bt.length);
    }
}
 
```
```java
class Solution {
    public long solve(int[] bt) {
        Arrays.sort(bt);
        int n = bt.length;
        long totalTime = 0;
        long clock = 0;
        for(int i=0;i<n;i++){
            totalTime += clock;
            clock += bt[i];
        }
        return totalTime/n;
    }
}

```

### Job Sequencing
Given a set of N jobs where each jobi has a deadline and profit associated with it.

Each job takes 1 unit of time to complete and only one job can be scheduled at a time. We earn the profit 
associated with job if and only if the job is completed by its deadline.
Find the number of jobs done and the maximum profit.

Note: Jobs will be given in the form (Jobid, Deadline, Profit) associated with that Job.

Example 1:

Input: N = 4, Jobs = {(1,4,20),(2,1,10),(3,1,40),(4,1,30)}

Output: 2 60

Explanation: The 3rd job with a deadline 1 is performed during the first unit of time .
The 1st job is performed during the second unit of time as its deadline is 4.
Profit = 40 + 20 = 60
```
We are given n jobs where all jobs takes same time to complete but different profits and different deadlines.
1. we need to complete jobs with max profits first. ( Sort the array as per profits in descending order )
2. Delay the jobs to the end days.
    for example we had a job which has max profit and deadline is x.
    we should try to aloocate this job at the xth day if that days is not already occupied by another job.
    if xth day is already allocated to some other job, which given max profit than this,
    we should try x-1 th day and then x-2 th day and so on..
    because of this, the earlier days will be free which might be useful for the other jobs.

- Sort the jobs as per profits in descening order.
- find the max deadline in the given array
- create and array of length n which represents the days to be allocated for jobs ( inititalize all with -1 )
- for each job:
    x = deadline of current job
        if xth day is already allocated:
            check previous days until an empty slot is found.
        else:
            allocate this job on the xth day.
```
In the question when the constraint is given  1 <= Deadline <= N following solution works.

otherwise find the max deadline and create days array of that size;
```java
public int[] JobScheduling(int[][] Jobs) {
    Arrays.sort(Jobs,(a,b)->b[2]-a[2]);
    int n = Jobs.length;
    int[] days = new int[n+1];
    int count = 0;
    int profit = 0;
    for(int i=0;i<n;i++){
        for(int day = Jobs[i][1] ; day>=1;day--){
            if(days[day]==0){
                profit += Jobs[i][2];
                count++;
                days[day]=1;
                break;
            }
        }
    }
    return new int[]{count,profit};
}

```

