### Shortest Job First
A software engineer is tasked with using the shortest job first (SJF) policy to calculate the average waiting time for each process. The shortest job first also known as shortest job next (SJN) scheduling policy selects the waiting process with the least execution time to run next.

Given an array of n integers representing the burst times of processes, determine the average waiting time for all processes and return the closest whole number that is less than or equal to the result.
```
bt = [4, 1, 3, 7, 2]
output is avg wt  = 4

Sort the array.
[1,2,3,4,7]
now, complete each task in the same order:
1 is completed -> 4 tasks waited 1 sec | 1 x 4
2 is completed -> 3 tasks waited 2 sec | 2 x 3
3 is completed -> 2 tasks waited 3 sec | 3 x 2
4 is completed -> 1 task  waited 4 sec | 4 x 1
7 is completed -> 0 tasks waited 7 sec | 0
total = 20
avg = 20/5 = 4
```
```java
class Solution {
    public long solve(int[] bt) {
        Arrays.sort(bt);
        int n=bt.length-1;
        long wt = 0;
        for(int i:bt){
            wt += i*n;
            n--;
        }
        return (int)(wt/bt.length);
    }
}
 
```
```java
class Solution {
    public long solve(int[] bt) {
        Arrays.sort(bt);
        int n = bt.length;
        long totalTime = 0;
        long clock = 0;
        for(int i=0;i<n;i++){
            totalTime += clock;
            clock += bt[i];
        }
        return totalTime/n;
    }
}

```

### Job Sequencing
Given a set of N jobs where each jobi has a deadline and profit associated with it.

Each job takes 1 unit of time to complete and only one job can be scheduled at a time. We earn the profit 
associated with job if and only if the job is completed by its deadline.
Find the number of jobs done and the maximum profit.

Note: Jobs will be given in the form (Jobid, Deadline, Profit) associated with that Job.

Example 1:

Input: N = 4, Jobs = {(1,4,20),(2,1,10),(3,1,40),(4,1,30)}

Output: 2 60

Explanation: The 3rd job with a deadline 1 is performed during the first unit of time .
The 1st job is performed during the second unit of time as its deadline is 4.
Profit = 40 + 20 = 60
```
We are given n jobs where all jobs takes same time to complete but different profits and different deadlines.
1. we need to complete jobs with max profits first. ( Sort the array as per profits in descending order )
2. Delay the jobs to the end days.
    for example we had a job which has max profit and deadline is x.
    we should try to aloocate this job at the xth day if that days is not already occupied by another job.
    if xth day is already allocated to some other job, which given max profit than this,
    we should try x-1 th day and then x-2 th day and so on..
    because of this, the earlier days will be free which might be useful for the other jobs.

- Sort the jobs as per profits in descening order.
- find the max deadline in the given array
- create and array of length n which represents the days to be allocated for jobs ( inititalize all with -1 )
- for each job:
    x = deadline of current job
        if xth day is already allocated:
            check previous days until an empty slot is found.
        else:
            allocate this job on the xth day.
```
In the question when the constraint is given  1 <= Deadline <= N following solution works.

otherwise find the max deadline and create days array of that size;
```java
public int[] JobScheduling(int[][] Jobs) {
    Arrays.sort(Jobs,(a,b)->b[2]-a[2]);
    int n = Jobs.length;
    int[] days = new int[n+1];
    int count = 0;
    int profit = 0;
    for(int i=0;i<n;i++){
        for(int day = Jobs[i][1] ; day>=1;day--){
            if(days[day]==0){
                profit += Jobs[i][2];
                count++;
                days[day]=1;
                break;
            }
        }
    }
    return new int[]{count,profit};
}

```

### N meetings in one room
Given one meeting room and N meetings represented by two arrays, start and end, where start[i] represents the start time of the ith meeting and end[i] represents the end time of the ith meeting, determine the maximum number of meetings that can be accommodated in the meeting room if only one meeting can be held at a time.
```
1. we need to start the meetings that can be ended faster.
2. if a meeting need to be started at time t, then the last meeting happened should be ended before t.

- sort the meetings according to their end time in increasing order.
- track the last meeting end time as lastEnded ( initially it will be -1 as no meeting started )
- for each meeting :
    if it's start time is greater than the lastEnded:
        this meeting can be started, increase count / add to the result
    else:
        this cannot be started as it will overlap with previous meeting.
   move to next.
```
```java
public int maxMeetings(int[] start, int[] end) {
    int n = start.length;
    int[][] meetings = new int[n][2];
    for(int i=0;i<n;i++){
        meetings[i][0] = start[i];
        meetings[i][1] = end[i];
    }
    Arrays.sort(meetings,(a,b)->a[1]-b[1]);
    int count = 1;
    int lastEnd = meetings[0][1];
    for(int i=1;i<n;i++){
        int s = meetings[i][0];
        int e = meetings[i][1];
        if(s>lastEnd){
            count++;
            lastEnd = e;
        }
    }
    return count;
}
```
### Non-overlapping Intervals
Given an array of N intervals in the form of (start[i], end[i]), where start[i] is the starting point of the interval and end[i] is the ending point of the interval, return the minimum number of intervals that need to be removed to make the remaining intervals non-overlapping.

Input : Intervals = [ [1, 2] , [2, 3] , [3, 4] ,[1, 3] ]

Output : 1

Explanation : You can remove the interval [1, 3] to make the remaining interval non overlapping.
```
This is similar to N Meetings in a room,
you have to maximize the no. of intevrals to be kept and remove minimum overlapping intervals.
instead of returning the maximum count of meetings that can happen,
return the count of the meetings those cannot be conducted.
```
```java
public int MaximumNonOverlappingIntervals(int[][] intervals) {
    int n = intervals.length;
    Arrays.sort(intervals,(a,b)->a[1]-b[1]);
    int count = 0;
    int lastEnd = -1;
    for(int i=0;i<n;i++){
        int s = intervals[i][0];
        int e = intervals[i][1];
        if(s>=lastEnd){
            count++;
            lastEnd = e;
        }
    }
    return n-count;
}
```

### Insert Interval
Given a 2D array Intervals, where Intervals[i] = [start[i], end[i]] represents the start and end of the ith interval, the array represents non-overlapping intervals sorted in ascending order by start[i]. 

Given another array newInterval, where newInterval = [start, end] represents the start and end of another interval, insert newInterval into Intervals such that Intervals remain non-overlapping and sorted in ascending order by start[i].

Return Intervals after the insertion of newInterval.

Input : Intervals = [ [1, 3] , [6, 9] ] , newInterval = [2, 5]

Output : [ [1, 5] , [6, 9] ]

Explanation : After inserting the newInterval the Intervals array becomes [ [1, 3] , [2, 5] , [6, 9] ].
So to make them non overlapping we can merge the intervals [1, 3] and [2, 5].

So the Intervals array is [ [1, 5] , [6, 9] ].
```
As the array is already sorted according to the start of intervals, we need to check where we can add our new interval.
when we insert a new interval in existing intervals, we will see 3 parts in intervals.
1. Intervals which are not overlapping and before the newInterval
2. Intervals which are overlapped with the newInterval
3. Intervals which are not overlapping and after the newInterval
For example:
Intervals = [ [1, 2] , [3, 5] , [6, 7] , [8,10] ] , newInterval = [4, 8]
when we insert new interval:
Intervals = [ [1, 2] , [3, 5] , [4, 8],  [6, 7] , [8,10] ]
now
1. [1, 2] is before newInterval and not over lapping
2. [3, 5] , [4, 8],  [6, 7] are intervals which are getting overlapped.
3. [8,10] is after the newInterval and not over lapping

- we can keep the intervals which are not overlapping as it is in the resultant intervals.
- the intervals which are overlapping we need to merge all of them togther to form a single new interval, and add it to the resultant.
    newInterval = [minimumStartingPoint,maximumEndingPoint] of all the overlapping intervals.
    if [3,5] [4,9], [7,8] are the intervals, the finals interval should be [3,9]
- If there are no overlapping intervals we can just add the given newInterval in the result.
```
**Approach:**
```
1. create a resultant array.
2. add each interval to result until an overlap encountered.
    how can we check if an interval to the left is not overlapped with newInterval ?
    if the intervals end time (interval[i][1])  is less than the newinterval's start time. (newInterval[0])
3. now we are at intervals which are getting overlapped, we have to find the merged interval.
    update the newInterval's start and end by checking all overlapped intervals.
    how to check if an interval is overlapped with the new Interval
    if the interval's start time (intervals[i][0]) is less than the newInterval's end time ( newInterval[1] )
4. now add all the remaining intervals on the right side, which are not overlapping
```
```java
public int[][] insertNewInterval(int[][] intervals, int[] newInterval) {
        int n = intervals.length;
        int i = 0;
        List<int[]> result = new ArrayList<>();
        // left non-overlapping
        while(i<n && intervals[i][1] < newInterval[0]){
            result.add(intervals[i]);
            i++;
        }
        // overlapped
        while(i<n && intervals[i][0] <= newInterval[1]){
            newInterval[0] = Math.min(newInterval[0],intervals[i][0]);
            newInterval[1] = Math.max(newInterval[1],intervals[i][1]);
            i++;
        }
        result.add(newInterval);
        // right non-overlapped
        while(i<n){
            result.add(intervals[i]);
            i++;
        }
        return result.toArray(new int[result.size()][]);
}
```
### Minimum number of platforms required for a railway
Given arrival and departure times of all trains that reach a railway station. 
Find the minimum number of platforms required for the railway station so that no train is kept waiting.
Consider that all the trains arrive on the same day and leave on the same day.
Arrival and departure time can never be the same for a train but we can have arrival time of one train equal to departure time of the other. 
At any given instance of time, same platform can not be used for both departure of a train and arrival of another train. In such cases, we need different platforms.

Input: n = 6 
arr[] = {0900, 0940, 0950, 1100, 1500, 1800}
dep[] = {0910, 1200, 1120, 1130, 1900, 2000}
Output: 3
Explanation: 
Minimum 3 platforms are required to 
safely arrive and depart all trains.

```
BruteForce:
for each train
    check how many are overlapping ?
    platformsRequired = 1 (curr train) + count of overlapped trains
return the max platformsRequired
```
```
Optimal:

arr[] = {0900, 0940, 0950, 1100, 1500, 1800}
dep[] = {0910, 1200, 1120, 1130, 1900, 2000}
Consider we have a clock, firstly we start at 0 and track count of required platforms in count variable.
clock at 0900 : train1 arrives - count = 1 ( train arrives - count increases )
clock at 0910 : train1 departs - count = 0 ( train departs - count decreases )
clock at 0940 : train2 arrives - count = 1 
clock at 0950 : train3 arrives - count = 2
clock at 1100 : train4 arrives - count = 3
clock at 1120 : train3 departs - count = 2
clock at 1130 : train4 departs - count = 1
clock at 1200 : train2 departs - count = 0
clock at 1500 : train5 arrives - count = 1
clock at 1800 : train6 arrives - count = 2
clock at 1900 : train5 departs - count = 1
clock at 2000 : train6 departs - count = 0

The max count is 3 which is required no. of platforms.

to check the clock at each event of arrival or departure, we need to sort the timings in the following order:
(0900,A), (0910,D), (0940,A), (0950,A), (1100,A), (1120,A), (1130,D), (1200,D) .......
Or 
we can sort Arrivals and Departs separately and keep two pointers to iterate each array.
```
```java
public int findPlatform(int[] Arrival, int[] Departure) {
    int n = Arrival.length;
    Arrays.sort(Arrival);
    Arrays.sort(Departure);
    int i=0,j=0;
    int required = 0;
    int ans = 0;
    while(i<n){
        if(Arrival[i] <= Departure[j]){
            required++;
            i++;
        }else{
            required--;
            j++;
        }
        ans = Math.max(ans,required);
    }
    return ans;
}
```
