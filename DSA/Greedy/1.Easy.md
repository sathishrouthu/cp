### Assign Cookies
Consider a scenario where a teacher wants to distribute cookies to students, with each student receiving at most one cookie.

Given two arrays, Student and Cookie, the ith value in the Student array describes the minimum size of cookie that the ith student can be assigned. The jth value in the Cookie array represents the size of the jth cookie. If Cookie[j] >= Student[i], the jth cookie can be assigned to the ith student. Maximize the number of students assigned with cookies and output the maximum number.

Student = [1, 2, 3] , Cookie = [1, 1] Output = 1

```
Sort both arrays
maintain two points 
i -> students
j -> cookies

since if students[i] <= cookies[j] : we can assign the cookie to student and move to next student and cookie : i++,j++
else: we cannot assign current cookie to any student, go to next cookie : j++;
at the end i ends up with the count of students assigned.

```
```java
public int findMaximumCookieStudents(int[] students, int[] cookies) {
    int m = students.length;
    int n = cookies.length;
    Arrays.sort(students);
    Arrays.sort(cookies);
    int i=0,j=0;
    while(i<m && j<n){
        if(students[i] <= cookies[j]){
            i++;
            j++;
        }else{
            j++;
        }
    }
    return i;
}
```

### Lemonade Change
Each lemonade at a booth sells for $5. Consumers are lining up to place individual orders, following the billing order. Every consumer will purchase a single lemonade and may pay with a $5, $10, or $20 bill. Each customer must receive the appropriate change so that the net transaction is $5. Initially, there is no change available.

Determine if it is possible to provide the correct change to every customer. Return true if the correct change can be given to every customer, and false otherwise.

Given an integer array bills, where bills[i] is the bill the ith customer pays, return true if the correct change can be given to every customer, and false otherwise.
```
maintain 2 variables to count no. of change coins available in shop.
five, ten. ( we don't need count of twenty as we cannot give it as a change )

when a customer pays $5 just increment the five and no need to give change,
when a customer pays $10 accept it only if we have at lest once five coin ( five > 0 ) then increment ten++ and decrement five--;
when a customer pays $20 accept it only if we have 1x10 + 1x5 or 3x5 ( (ten > 0 && five>0) || (five>3) ) then decrement the respective change coins.

```
```java

public boolean lemonadeChange(int[] nums) {
    int five=0, ten=0;
    for(int n : nums){
        if(n==5) {
            five++;
        }
        else if(n==10) {
            if(five>0){
                ten++;
                five--;
            }else{
                return false;
            }
        }
        else if(n==20){
            if(ten>0 && five>0){
                ten--;
                five--;
            }else if(five>2){
                five-=3;
            }else{
                return false;
            }
        }
    }
    return true;
}

```

### Jump Game - I
Given an array of integers nums, each element in the array represents the maximum jump length at that position. Initially starting at the first index of the array, determine if it is possible to reach the last index. Return true if the last index can be reached, otherwise return false.
```
Maintain a variable maxReachable which tells the farthest position that can reached from current index or any index before current index.
at any point if current index is less than maxReachable then it means we cannot reach the current index from any of the prev indices, so we return false.
to find farthest reachable postion from a given point is : ( current index + nums[i] )

at any point if the maxReachable became greater than or equal to last index (n-1) that means we directly jump to last index, so we can return true directly.
```
```java
public boolean canJump(int[] nums) {
    int n = nums.length;
    int maxReachable = nums[0];
    for(int i=1;i<n;i++){
        if(maxReachable < i) return false;
        maxReachable = Math.max(maxReachable, i+nums[i]);
        if(maxReachable == n-1) return true;
    }
    return true;
}
```




