### ValidParanthesis.md
Find the validity of an input string s that only contains the letters '(', ')' and '*'.

A string entered is legitimate if

Any left parenthesis '(' must have a corresponding right parenthesis ')'.
Any right parenthesis ')' must have a corresponding left parenthesis '('.
Left parenthesis '(' must go before the corresponding right parenthesis ')'.
'*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string "".

**Bruteforce**:

- check all possibilities of asterick using recusrion, can be optimized using dp.
```java
 private boolean checkValid(int ind, int count, String s, int[][] dp) {
        // Base case 
        if (count < 0) return false;
        // Base case
        if (ind == s.length()) {
            return (count == 0);
        }

        // If already computed, return the value directly
        if (dp[ind][count] != -1) return dp[ind][count] == 1;

        boolean ans = false;

        // If the current index has '('
        if (s.charAt(ind) == '(')
            ans = checkValid(ind + 1, count + 1, s, dp);
        // If the current index has ')'
        else if (s.charAt(ind) == ')')
            ans = checkValid(ind + 1, count - 1, s, dp);
        
        // else if the current index has '*'
        else {
            for (int i = -1; i <= 1; i++) {
                ans = ans || checkValid(ind + 1, count + i, s, dp);
            }
        }

        // Store the value in DP and return the value
        dp[ind][count] = ans ? 1 : 0;
        return ans;
    }

```
**Optimal**
```
in prevoius approach we are using count to check balance b/w open and closed parnthesis.
now, to handle astericks we can maintain two variables which represents possible values of count of open paranthesis.
minOpen: represents minimum possible no. of open paranthesis remain at end.
maxOpen: represents maximum possible no. of open paranthesis remain at end.

if we encounter a '(' : both minOpen and maxOpen are incremented,
if we encounter a ')' : both minOpen and maxOpen are decremented (since it will close a open paranthesis )
if we encounter a '*' : minOpen should be decremented ( assuming '*' as a ')' )
                        maxOpen should be incremented ( assuming '*' as a '(' )
at any case:
if maxOpen < 0 then it means that a closing appeared without any opening before which is invalid. ( return false )
if minOpen < 0 then we assumed a closing without it's opening, we should not use ')' for * when there is no '(' before.
               ( reset minOpen to 0 ) minOpen should be decreased only if it is greater than 0.
At the end:
minOpen should be 0, if the string is a valid.
otherwise it is not valid and leaves some open paranthesis
```
```java
  public boolean isValid(String s) {
      int minOpen=0,maxOpen=0;
      for(char c:s.toCharArray()){
          if(c=='('){
              minOpen++;
              maxOpen++;
          }else if(c==')'){
              maxOpen--;
              minOpen--;
          }else{
              minOpen--;
              maxOpen++;
          }
          if(maxOpen < 0) return false;
          if(minOpen < 0) minOpen = 0;
      }
      return minOpen==0;
  }
```

### Candy
```
A line of N kids is standing there. The rating values listed in the integer array ratings are assigned to each kid.
These kids are receiving candy, according to the following criteria:
1) There must be at least one candy for every child.
2) Kids whose scores are higher than their neighbours receive more candies than their neighbours.
Return the minimum number of candies needed to distribute among children.

Input : ratings = [1, 0, 5]
Output : 5
Explanation : The distribution of candies will be 2 , 1 , 2 to first , second , third child respectively.

Input : ratings = [1, 2, 2]
Output : 4
Explanation : The distribution of candies will be 1 , 2 , 1 to first , second , third child respectively.
              The third gets only 1 candy because it satisfy above two criteria.
```
**Approach 1:**
```
First, scan the children from left to right, giving more candies to those with higher ratings than the child before them.
Then, scan from right to left, ensuring children with higher ratings than the children after them also get more candies.
The total number of candies needed is the sum of the maximum number of candies assigned from both directions for each child.
for example: ratings = [1,0,5]
when we look at left neighbours only:
candies to be given
for rating 1 : 1 - no left neighbour
for rating 0 : 1 - rating is less than left neighbour
for rating 5 : 2 - raging greater than left neighbour, increase candies just by 1 ( to use minimum )
candies: [1 , 1, 2]
when we look at right neighbours only:
candies to be given
for rating 1 : 2 - rating is greater than right neighbour
for rating 0 : 1 - rating is less than right neighbour
for rating 5 : 1 - no right neighbour
candies : [2, 1, 1]
by checking both directions:
for rating 1: we should give max of left and right directions which is : 2
for rating 2: we should give max of left and right directions which is : 1
for rating 5: we should give max of left and right directions which is : 2
Answer: [2, 1, 2 ] total = 5
```
```java
public int candy(int[] ratings) {
    int n = ratings.length;
    int[] left = new int[n];
    int[] right = new int[n];
    left[0]=1;
    right[n-1]=1;
    for(int i=1;i<n;i++){
        if(ratings[i] > ratings[i-1]){
            left[i]=left[i-1]+1;
        }
        else{
            left[i]=1;
        }
        if(ratings[n-1-i] > ratings[n-i]){
            right[n-i-1] = right[n-i]+1;
        }else{
            right[n-i-1] = 1;
        }
    }
    int ans = 0;
    for(int i=0;i<n;i++){
        ans += Math.max(left[i],right[i]);
    }
    return ans;
}
```

**Optimal using slope concept**
```

```



