##### Longest common subsequence
1. Given two strings str1 and str2, find the length of their longest common subsequence.
   A subsequence is a sequence that appears in the same relative order but not necessarily contiguous and a common subsequence of two strings is a subsequence that is common to both strings.
```
use two pointers to recursively match characters in string
if both chars matches: move to next in both
else: move to next in each string separately
i--> s1 and j-->s2
if s1[i]==s2[j]:
  return 1+f(i-1,j-1)
else
  return max( f(i-1,j), f(i,j-1) )
```
##### Longest common substring
2. Given two strings str1 and str2, find the length of their longest common substring.
   A substring is a contiguous sequence of characters within a string.
```
when two chars don't match we lost the contingousness and return 0;
but the answer is not guaranteed at f(m-1,n-1) answer can be from any f(i,j) for i->0 to m-1 and j->0 to n-1

Use tabulation:
set dp[i][j]=0 when s1[i]!=s2[j]
answer is the max value in entire dp array.
```
##### Longest palindromic subsequence
3. Given a string, Find the longest palindromic subsequence length in given string.
   A palindrome is a sequence that reads the same backwards as forward
```
find the lcs of string and reverse of given string
```
##### Minimum insertions to make string palindrome
4. Given a string s, find the minimum number of insertions needed to make it a palindrome.
```
Ans = size of string - Longest palindromic subsequence
```
##### Minimum insertions or deletions to convert string A to B
5. Given two strings str1 and str2, find the minimum number of insertions and deletions in string str1 required to transform str1 into str2.
   Insertion and deletion of characters can take place at any position in the string.
   ```
   do not touch longest common subsequence, only insert/delete the chars that are not part of lcs.
   str1 is of length m and str2 is of length n
   let's say we found lcs = k
   we need to remove m-k chars from str1 and insert n-k chars into str1 to transform it to str2.
   ```
##### Shortest common supersequence
6. Given two strings str1 and str2, find the shortest common supersequence.
   The shortest common supersequence is the shortest string that contains both str1 and str2 as subsequences.
   ```
   keep characters that are part of lcs only once in super sequence and insert the character that not part of lcs around the lcs characters.
   min length of supersequence is: m+n - len(lcs)

   to find the least super sequence:
   trace back the dp array of lcs.
   
   start from right most corner of array.
   if both characters are equal ( it is an lcs char and include only once in answer )
   else:
      we include only of them in answer and move to top or left whichever is greater.
      if we move to top  ( i-1 ) include char at i;
      if we move to left ( j-1 ) include char at j;
   
   if s1 or s2 still has chars: include all of them ( only one string will be left with chars. )
   ```
##### Distinct subsequences equals to a given String
7. Given two strings s and t, return the number of distinct subsequences of s that equal t.
   The task is to count how many different ways we can form t from s by deleting some (or no) characters from s.
   ```
   compare chars of both the string using i and j
   when they both match:
      move to next char in t and s. :: f(i-1,j-1)
      +
      move to next char only in s (to check if the s has other matching char of t[j] ) :: f(i-1,j)
   when they dont match:
      move only to next char in s ( still we need to match t[j] ) :: f(i-1,j)
   ```
##### Edit distance
8. Given two strings start and target, you need to determine the minimum number of operations required to convert the string start into the string target. The operations you can use are:
   1. Insert a character: Add any single character at any position in the string.
   2. Delete a character: Remove any single character from the string.
   3. Replace a character: Change any single character in the string to another character.
The goal is to transform start into target using the minimum number of these operations.
   ```
   compare both strings s and t using i and j
   when they both matches we keep them intact and move to next f(i-1,j-1)
   inserting :
      hypothetically insert a char at i+1 and assume s[i+1] and t[j] matches move to next char respectively:
      next chars
         for s: i ( since we assumed to insert a char at i+1 and moved to i+1-1 )
         for t: j-1
      f(i,j-1)
   deleting:
      move to next in s and stay at same place for t ( we still need to match t[j] )
      f(i-1,j)
   replacing:
      we replaced s[i] with t[j] since they both match now we move to next in both strings
      f(i-1,j-1)
   
   since we need minimum return the min of ( insert,delete,replace )
   ```
##### Wildcard matching
9. Given a string str and a pattern pat, implement a pattern matching function that supports the following special characters:
   1. '?' Matches any single character.
   2. '*' Matches any sequence of characters (including the empty sequence).
The pattern must match the entire string.
```
compare the both string using i and j
if both chars matches OR pattern[j] is '?' we match it with one character and move to next:
   f(i-1,j-1)
else if pattern[j] is '*' we match it with either more or none in string.
   more = f(i-1,j)
   none = f(i,j-1)
else
   we had a char in pattern that doesn't match with corresponding char in string: retrun false
In the base case:
when both string are exhausted (i<0 && j<0 ), we return true as they matched entirely. 
if we still has chars left in pattern (i<0), we should check if all the left characters are only '*'. 
if we still has chars left in string (j<0), then we are out of pattern to match and return false. 
```
